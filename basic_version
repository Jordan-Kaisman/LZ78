"""
LZ78 Compression

Output Stream: 32-bit length header, followed by tuples (parent_index, next_char). The parent prase is already 
in the dictionary and is being extended by next_char. 

Dictionary: maps (parent_index, next_char) -> child_index. 

Dictionary Management: freeze once full
"""

from dataclasses import dataclass
from scl.utils.bitarray_utils import BitArray, bitarray_to_uint, uint_to_bitarray

@dataclass
class LZ78Tuple:
    """
    parent_index: pointer to parent phrase (root is 0)
    next_char: byte value
    """
    parent_index: int 
    next_char: int

class LZ78EncoderDictionary:
    """
    Hash (parent_index, character) -> child_index
    Empty string at index 0 (root)
    """

    def __init__(self, max_size=4096):
        """next_index: next available index"""
        self.dictionary = {}
        self.next_index = 1 
        self.max_size = max_size
    
    def search(self, parent_index, next_char):
        """Returns child_index if key is found, None otherwise"""
        return self.dictionary.get((parent_index, next_char))

    def insert(self, parent_index, next_char):
        """Adds {(parent_index, next_char): next_index} if dictionary not full"""
        if self.next_index < self.max_size:
            self.dictionary[(parent_index, next_char)] = self.next_index
            self.next_index += 1


class LZ78DecoderDictionary:
    """
    Reversed: maps child_index -> (parent_index, character) 
    """

    def __init__(self, max_size=4096):
        """Initialize dictionary with the empty string at index 0"""
        self.dictionary = {0: (None,None)}
        self.next_index = 1
        self.max_size = max_size

    def insert(self, parent_index, next_char):
        """Adds {next_index: (parent_index, next_char)} if dictionary not full"""
        if self.next_index < self.max_size:
            self.dictionary[self.next_index] = (parent_index, next_char)
            self.next_index += 1
    
    def unravel_phrase(self, index):
        """
        Work backwards to construct the phrase at given index, repeatedly adding the last character and then 
        checking the dictionry entry at parent index
        """
        chars = []
        current_index = index
        
        while current_index != 0:
            parent_index, char = self.dictionary[current_index]
            if char is not None:
                chars.append(char)
            current_index = parent_index
        
        chars.reverse()
        return bytes(chars)


class LZ78Encoder:
    """
    Processes data using an LZ78EncodeDictionary 
    """

    def __init__(self, max_size=4096):
        self.max_size = max_size
        self.dictionary = LZ78EncodeDictionary(max_size)

    def encode(self, data: bytearray):
        """
        Produces stream of LZ78Tuples while constructing dictionary

        Leftover: we only ouput a tuple when a new phrase is encountered. But it is possible (in fact likely) that the 
        last few bytes will match with an existing phrase, so that no outout is produced. We can include this partial phrase 
        by forming a tuple from the parent_index and placeholder char 0. The decoder, which knows the length, will be able to 
        identify the placeholder.
        
        """
        stream = []
        parent_index = 0
        for char in data:
            child_index = self.dictionary.search(parent_index, char)
            # If end of phrase, add tuple to stream and dictionary
            if child_index is None: 
                stream.append(LZ78Tuple(parent_index, char))
                self.dictionary.insert(parent_index, char)
                parent_index = 0
            # Else, keep building phrase
            else: 
                parent_index = child_index
        
        # Handle leftover 
        if parent_index != 0:
            stream.append(LZ78Tuple(parent_index, 0))

        return stream
    
    def encode_binary(self, data):
        """
        Encodes data as a bitarray

        32 bit length header
        Tuples: (12 bit index, 8 bit char) 
        """
        bit_stream = BitArray()
        bit_stream += uint_to_bitarray(len(data), 32)
        tuples = self.encode(data)
        for tuple in tuples:
            bit_stream += uint_to_bitarray(tuple.parent_index, 12)
            bit_stream += uint_to_bitarray(tuple.next_char, 8)

        return bit_stream


class LZ78Decoder:

    def __init__(self, max_size=4096):
        self.max_size = max_size
        self.dictionary = LZ78DecodeDictionary(max_size)
    
    def decode(self, tuples, length):
        """
        Takes in stream of tuples, produces bytearray of characters 
        """
        output = bytearray()

        for tuple in tuples:
            phrase = self.dictionary.unravel_phrase(tuple.parent_index)
            output.extend(phrase)
            output.append(tuple.next_char)

            self.dictionary.insert(tuple.parent_index, tuple.next_char)

        output = output[:length] # clips the (potential) placeholder byte
        return output 


    def decode_binary(self, bit_stream):
        length = bitarray_to_uint(bit_stream[:32])
        tuples = []
        for i in range(32,len(bit_stream),20):
            index = bitarray_to_uint(bit_stream[i:i+12])
            char = bitarray_to_uint(bit_stream[i+12:i+20])
            tuples.append(LZ78Tuple(index, char))

        return self.decode(tuples, length)
